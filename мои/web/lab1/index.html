<!DOCTYPE html>
<html>
    <head>
        <style>
            p.pref{
               
            }
        </style>



        <title>лабораторная 1</title>
        <link rel="stylesheet" href="css/figure_image.css">
        <link rel="stylesheet" href="css/list.css">
        <link rel="stylesheet" href="css/text.css">
        <link rel="stylesheet" href="css/table.css">
        <link rel="stylesheet" href="css/codeStyle.css">
        <link rel="stylesheet" href="css/normalize.css">
        <meta charset="utf-8">
    </head>
    <body>
        <header>
            <h1 class="centered">Ассемблер и язык ассемблера</h1>
            <p class="centered description">Ассемблер и язык ассемблера. История.Обзор.Применение.</p>
        </header>
        <hr>
        <h2>Содержание</h2>            
        <ul class="custom">
            <li class="custom" ><a class = "contentRef" href="#shortInfo">Кратко об ассемблере и языке ассемблера</a></li>
            <li class="custom" ><a class = "contentRef" href="#history">История создания</a></li>
            <li class="custom" ><a class = "contentRef" href="#aboutAssembly">Об ассемблере</a></li>
            <li class="custom" ><a class = "contentRef" href="#aboutAssemblyLang">О языке ассемблера</a></li>
            <li class="custom" ><a class = "contentRef" href="#langinfo">Обзор языка</a></li>
            <li class="custom" ><a class = "contentRef" href="#code">Примеры кода</a></li>
            <li class="custom" ><a class = "contentRef" href="#using">Применение</a></li>
            <li class="custom"><a class = "contentRef" href="#after">Вывод</a></li>
            <li class="custom" ><a class = "contentRef" href="html/tags_styles.html">Список тегов и стилей</a></li>
        </ul>
    
        <h2 id="shortInfo">Кратко об ассемблере и языке ассемблера</h2>
        <p><b><i>Ассемблер</i></b> — это программное обеспечение, которое преобразует код языка ассемблера в машинный код. 
            Он принимает основные команды компьютера и преобразует их в двоичный код,
             который процессор компьютера может использовать для выполнения своих основных операций. 
             Эти инструкции написаны на языке ассемблера или языке ассемблера.<br>
            Мы также можем назвать ассемблер компилятором языка ассемблера.
            Это связано с тем, что компилятор преобразует язык высокого уровня в машинный язык.
            С другой стороны, ассемблер выполняет ту же задачу, но для языка ассемблера он называется компилятором языка
            ассемблера.</p>
        <p><b><i>Язык ассемблера</i></b> — это язык низкого уровня.
           Он дает инструкции процессорам для выполнения различных задач.
           <img src="source/images/assembler_logo.png" alt="assembler logo" style="float:right; width: 100px;height: 100px;">
           Это специфично для любого процессора. Машинный язык состоит только из 0 и 1, 
           поэтому на нем сложно написать программу. С другой стороны,
           язык ассемблера близок к машинному языку, но имеет более простой язык и код.
           Мы можем создать код на ассемблере с помощью компилятора или программист может написать его напрямую. 
           В основном программисты используют языки высокого уровня,
           но когда требуется более конкретный код, используется ассемблер. 
           Он использует код операции для инструкций. Код операции в основном предоставляет информацию о конкретной 
           инструкции. Символическое представление кода операции (инструкции машинного уровня) называется мнемоникой . 
           Инструкции. Символическое представление кода операции (инструкции машинного уровня) называется мнемоникой . 
           Программисты используют их для запоминания операций на языке ассемблера.
        </p>

        <h2 id="history">История создания</h2>
        <p>Первые ассемблеры были спроектированы 
            <a href="https://ru.wikipedia.org/wiki/%D0%91%D1%83%D1%82,_%D0%9A%D1%8D%D1%82%D0%BB%D0%B8%D0%BD">Кэтлин Бут</a> 
            и <a href="https://en.wikipedia.org/wiki/David_Wheeler_(computer_scientist)"> Дэвидом Уилером</a> 
            в 1947 под ARC2 и Дэвидом Уилером  в 1948 под EDSAC, 
            при этом термин «ассемблер» не использовали, просто называя язык «множеством базовых команд»
            и «начальными командами» соответственно. 
            Впервые термин «ассемблер» для процесса объединения полей в командное слово начали использовать более поздние отчёты по EDSAC.
            Также на ранних этапах развития программирования было введено понятие 
            автокод — язык программирования, предложения которого по своей структуре в основном подобны командам и 
            обрабатываемым данным конкретного машинного языка. В настоящее время термин фактически не используется.<br>

            Исторически, если первым поколением языков программирования считать машинные коды, 
            то язык ассемблера можно рассматривать как второе поколение языков программирования. 
            Недостатки языка ассемблера, например, сложность разработки на нём больших программных комплексов, 
            позже привели к появлению языков третьего поколения — языков программирования высокого 
            уровня (таких как <a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82%D1%80%D0%B0%D0%BD"> Фортран</a>, 
            <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF"> Лисп</a>, 
            <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B1%D0%BE%D0%BB"> Кобол</a>, 
            <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8C_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"> Паскаль</a>, 
            <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"> Си</a>
            и другие).
        </p>

        <figure class = "assemblyProcess">
        <p>
            <img src="source/images/img-w7OXqt.png" alt="Процесс разработки программы на языке ассемблера" title="Процесс разработки программы на языке ассемблера" class="asmLogo">
        </p>
            <figcaption>Процесс разработки программы<br> на языке ассемблера</figcaption>
        </figure>
        <h2 id="aboutAssembly">Об ассемблере</h2>
        <p>
            <b><i>Ассемблер</i></b> (от англ. assembler — сборщик) — транслятор 
            программы из текста на языке ассемблера, в программу на машинном языке.
            Как и сам язык, ассемблеры, как правило, специфичны для конкретной архитектуры,
            операционной системы и варианта синтаксиса языка, поскольку работают с мнемониками
            машинных инструкций определённого процессора. Вместе с тем, ассемблеры могут быть мультиплатформенными 
            или вовсе универсальными, то есть работать на разных платформах и операционных системах. 
            Среди ассемблеров можно также выделить группу кросс-ассемблеров, имеющих возможность собирать 
            машинный код и исполняемые модули (файлы) для архитектур, отличных от архитектуры и/или операционной системы, 
            в которых работает сам ассемблер (например, трансляция программы для микроконтроллера ассемблером, 
            работающим на компьютере).<br>

            Многие современные ассемблеры являются макроассемблерами, 
            то есть макропроцессорами на базе языка ассемблера. 
            Кроме макросов, ассемблеры при трансляции выполняют другие 
            директивы, набор которых зависит не от аппаратной платформы, 
            для которой транслируется программа, 
            а от самого используемого транслятора.</p>
            <p>Ассемблирование может быть не первым и не 
            последним этапом на пути получения исполнимого модуля программы. 
            Так, многие компиляторы с языков программирования высокого уровня выдают результат в виде программы на языке ассемблера, 
            которую в дальнейшем обрабатывает ассемблер. В свою очередь, результатом ассемблирования может быть не исполняемый, 
            а объектный модуль, содержащий разрозненные блоки машинного кода и данных программы, из которого (или из нескольких объектных 
            модулей) в дальнейшем с помощью редактора связей (линкера) может быть получен исполняемый файл.<br>

            В отличие от компиляции программ на языках высокого уровня, ассемблирование является более или менее однозначным и обратимым процессом, 
            поскольку в языке ассемблера каждой мнемонике соответствует одна машинная инструкция, 
            в то время как в высокоуровневых языках каждое выражение может преобразовываться в большое число различных инструкций 
            (операция, обратная ассемблированию, называется дизассемблированием). Трансляцию ассемблерных программ иногда также называют 
            компиляцией.
        </p>
        <h3><b>Архитектура x86:</b></h3>
        <ul> 
            <li>Ассемблеры для DOS</li>
            <p class="inUL">Наиболее известными 
                            ассемблерами для операционной системы DOS являлись Borland Turbo Assembler (TASM), 
                            Microsoft Macro Assembler (MASM) и Watcom Assembler (WASM). Также в своё время был популярен 
                            простой ассемблер A86.
            </p>
            <li>Windows</li>
            <p class="inUL">
                    При появлении операционной системы Windows появилось расширение TASM, именуемое TASM 5+ 
                    (неофициальный пакет, созданный человеком с ником neonovd’), позволившее создавать программы для выполнения в среде 
                    Windows. Последняя известная версия TASM — 5.3, поддерживающая инструкции MMX, на данный момент включена в Turbo C++ 
                    Explorer. Но официально развитие программы полностью остановлено. Последнее развитие компилятор получил благодаря 
                    современной среде разработки TASM Visual. Среда неофициальная, но с её помощью работа с компилятором многократно 
                    упрощается.<br>

                    Microsoft поддерживает свой продукт под названием Microsoft Macro Assembler. Она продолжает развиваться и по сей день, 
                    последние версии включены в наборы DDK. Но версия программы, направленная на создание программ для DOS, не развивается. 
                    Кроме того, Стивен Хатчессон создал пакет для программирования на MASM под названием «MASM32».
            </p>
            <li>GNU и Linux</li>
            <p class="inUL">
                В состав операционной системы GNU входит пакет binutils, включающий в себя ассемблер GAS (GNU Assembler), использующий 
                AT&T-синтаксис, в отличие от большинства других популярных ассемблеров, которые используют Intel-синтаксис (поддерживается 
                с версии 2.10).
            </p>
            <li>Переносимые ассемблеры</li>
            <p class="inUL">Также существует открытый проект ассемблера, версии которого доступны под различные операционные системы, и 
                который позволяет получать объектные файлы для этих систем. Называется этот ассемблер NASM (Netwide Assembler).<br>
                Yasm — это переписанная с нуля версия NASM под лицензией BSD (с некоторыми исключениями).
                flat assembler (fasm) — молодой ассемблер под модифицированной для запрета перелицензирования (в том числе под GNU GPL) 
                BSD-лицензией. Есть версии для KolibriOS, Linux, DOS и Windows; использует Intel-синтаксис и поддерживает инструкции x86-64.</p>
        </ul>
        <br>
        <h3><b>Архитектуры RISC:</b></h3>
        <ul>
            <li>MCS-51</li>
            <p class="inUL">MCS-51 (Intel 8051) — классическая архитектура микроконтроллера. Для неё существует кросс-ассемблер ASM51, 
                выпущенный корпорацией MetaLink.<br>
                Кроме того, многие фирмы-разработчики программного обеспечения, такие, как IAR или Keil, представили свои варианты 
                ассемблеров. В ряде случаев применение этих ассемблеров оказывается более эффективным благодаря удобному набору 
                директив и наличию среды программирования, объединяющей в себе профессиональный ассемблер и язык программирования Си, 
                отладчик и менеджер программных проектов.</p>
            <li>AVR</li>
            <p class="inUL">На данный момент для AVR существуют 4 компилятора производства Atmel (AVRStudio 3, AVRStudio 4, AVRStudio 5 и 
                AVRStudio 6, AVRStudio 7). В рамках проекта AVR-GCC (он же WinAVR) существует компилятор avr-as (это портированный под AVR
                ассемблер GNU as из GCC).Также существует свободный минималистический компилятор avra. Платные компиляторы: IAR (EWAVR), 
                CodeVisionAVR, Imagecraft. Данные компиляторы поддерживают языки Assembler и C, а IAR ещё и C++. 
                Существует компилятор с языка BASIC — BASCOM, также платный.
            </p>
            <li>ARM</li>
            <p class="inUL">
                Для процессоров ARM существует достаточно широкий выбор компиляторов, внутренняя реализация которых зависит от 
                непосредственно производителя данного ARM-процессора либо разработчика IDE для работы с ARM-процессорами. 
                Официальным компилятором ARM, непосредственно от компании ARM, является ARM Compiler 6, который входит в IDE DS-5 
                Development Studio и поддерживает компиляцию программ на языках Си и C++. Компиляторы от поставщиков ARM процессоров и 
                разработчиков ARM toolchain:
            </p>
        </ul>

        <table class="t1" summary="Компиляторы от поставщиков ARM процессоров и разработчиков ARM toolchain">
            <thead>
                <tr>
                    <th>№</th>
                    <th>Поставщик IDE</th>
                    <th>Компилятор</th>
                    <th>Поддерживаемые языки</th>
                    <th>Условия использования</th>
                </tr>
                <tfoot>
                    <tr>
                      <th colspan="5">www.lab1.lab</th>
                    </tr>
                  </tfoot>
              <tbody>
                <tr>
                    <th>1.</th>
                    <td>Keil mVision</td>
                    <td>MDK-ARM</td>
                    <td>Си/C++/Assembler</td>
                    <td>Shareware (не более 32kb)</td>
                </tr>
                <tr>
                    <th>2.</th>
                    <td>IAR Embedded Workbench</td>
                    <td>IAR Compiller</td>
                    <td>Си/C++/Assembler</td>
                    <td>Commercial</td>
                    
                </tr>
                <tr>
                    <th>3.</th>
                    <td>CoIDE</td>
                    <td>GCC compiler</td>
                    <td>Си/C++/Assembler</td>
                    <td>Free/Commercial</td>
                </tr> 
                <tr>
                    <th>4.</th>
                    <td>True Studio</td>
                    <td>Precompiled GCC compiler</td>
                    <td>Си/C++/Assembler</td>
                    <td>Free/Commercial</td>
                </tr>
              </tbody>               
            </thead>
        </table>
        <h2 id="aboutAssemblyLang">Язык ассемблера</h2>
        <p>
            Не существует общеупотребительного синтаксиса языка ассемблера. Так как системы команд различных процессоров значительно 
           отличаются, также и отличаются языки ассемблера для этих процессоров. Кроме того, каждая программа-ассемблер может использовать 
           отличающийся от других синтаксис. В ассемблерах для процессоров x86 наибольшее распространение получил так называемый 
           Intel-синтаксис, в меньшей степени — синтаксис AT&T.
        </p>
           <p>
           Базовой конструкцией языка ассемблера является мнемоника, или мнемокод — краткое символьное представление команды процессора. 
           Как правило, она состоит из нескольких символов, обозначающих производимое действие (например, mov — для пересылки из одного 
           регистра в другой, add — для сложения значений и т.д.). Также в мнемонику может входить объект, над которым производится 
           операция (регистр, память, стек), либо другие особенности (влияние на регистр флагов, условия исполнения и т.д.), однако в 
           других диалектах те же особенности могут задаваться в операндах.
        </p>
        <p>
           Как правило, ассемблер каждого процессора имеет свой традиционный набор мнемоник, но встречаются ассемблеры с кроссплатформенным 
           синтаксисом (такие, как синтаксис AT&T), однако кроссплатформенными в них остаются только обозначения, код одного процессора не 
           может быть напрямую перенесён на другой.
        </p>
        <p>
            В качестве операндов могут указываться регистры, константные значения, адреса ячеек памяти и портов ввода-вывода, 
            константы, метки и т.д. Разные ассемблеры могут требовать разного порядка операндов: в одних реализациях первым идёт оператор, 
            в который записывается значение, в других он идёт последним. Как правило, операнды отделяются от мнемоник команд пробелами.
        </p>
        
        <h2 id="langinfo">Обзор языка <a href="https://habr.com/ru/articles/569204/">(ссылка)</a></h2>
            <p class="centered"><img src="source/images/asm.png" title="так выглядит отладчик" alt="assembly"> </p>
        <p>
            Синтаксис директив, стандартных макросов и пр. структурных элементов различных диалектов (к примеру, MASM, fasm, NASM, GAS), 
            могут отличаться довольно существенно. Мнемоники (имена) инструкций (команд) и регистров, а также синтаксис их написания для 
            одного и того же процессора примерно одинаковы почти во всех диалектах (заметным исключением среди популярных ассемблеров 
            является разве что GAS (GNU Assembler) в режиме синтаксиса AT&T для x86, где к именам инструкций могут добавляться суффиксы, 
            обозначающие размер обрабатываемых ими данных, что бывает довольно удобно, но там есть и другие нюансы, сбивающие с толку 
            программиста, привыкшего к классическому ассемблеру, к примеру, иной порядок указания операндов, хотя всё это лечится специальной директивой переключения в режим классического синтаксиса Intel).

            Поскольку ассемблер – самый низкоуровневый язык программирования, довольно проблематично написать код, который корректно 
            компилировался бы для разных архитектур процессоров (например, x86 и ARM), для разных режимов одного и того же процессора 
            (16-битный реальный режим, 32-битный защищённый режим, 64-битный long mode; а ещё код может быть написан как с использованием 
            различных технологий вроде SSE, AVX, FMA, BMI и AES-NI, так и без них) и для разных операционных систем (Windows, Linux, 
            MS-DOS). Хоть иногда и можно встретить «универсальный» код (например, отдельные библиотеки), скажем, для 32- и 64-битного кода 
            ОС Windows (или даже для Windows и Linux), но это бывает нечасто. Ведь каждая строка кода на ассемблере (не считая управляющих 
            директив, макросов и тому подобного) – это отдельная инструкция, которая пишется для конкретного процессора и ОС, и сделать 
            кроссплатформенный вариант можно только с помощью макросов и условных директив препроцессора, получая в итоге порой весьма 
            нетривиальные конструкции, сложные для понимания.
        </p>
        <ol>
            <p><li>Ассемблер даёт полный контроль над кодом и обладает большей гибкостью, чем любой другой язык программирования 
                (даже C/C++). На асме мы можем конструировать нашу программу, размещая блоки кода и данных как нам вздумается. 
                Каждый генерируемый байт будет таким, каким мы хотим его видеть. Без лишнего runtime-кода стандартных библиотек. 
                Правда, справедливости ради отмечу, что необходимость в этом может возникнуть лишь в весьма специфических случаях.
                Однако существуют аппаратные платформы с ограниченными ресурсами, где оптимизация кода важна и актуальна и в наши дни.
            </li></p>
            <p><li>
                На ассемблере можно написать всё, он всемогущ! Вряд ли у вас получится создать MBR-загрузчик полностью на C или на 
                чём-то ещё. Для работы с железом на низком уровне, программирования чипсетов зачастую может потребоваться ассемблер. 
                Для внедрения кода в другие процессы (injection, не только с вредоносными целями), создания различных антиотладочных 
                приёмов тоже необходим ассемблер. Или, скажем, для проделывания чего-то вроде этого. Для C/C++ имеются интринсики – 
                функции для генерации отдельных инструкций процессора (есть ли что-то подобное для других языков программирования – 
                не знаю, не встречал). Но их частое использование загромождает код (не проще ли тогда писать на чистом ассемблере?) 
                А их отсутствие не позволяет нам контролировать генерируемый компилятором код (при этом, к слову говоря, Visual C/C++, 
                GNU C/C++ и Clang будут генерировать разный код; и даже один и тот же компилятор с разными настройками выдаст различный 
                результат).
            </li></p>
            <p>
                <li>
                    Получаемый код даже самого умного и навороченного компилятора, как правило, можно оптимизировать (как по скорости, 
                    так и по размеру). К примеру, автоматическую векторизацию кода (приведение обычных скалярных вычислений к параллельным 
                    вычислениям с использованием SIMD: SSE, AVX и т.п.), компиляторы C/C++ делают весьма посредственно. А ещё можно 
                    изощриться и использовать неочевидные комбинации, сделав код короче и быстрее. Этим можно, конечно, заняться и на 
                    других языках, но на ассемблере больше простора для творчества. К тому же, это особый кайф, азарт, челлендж в 
                    некотором роде! Разве не прикольно написать программу, выполняющую полезные функции, весом менее 10 Кб?  Для 
                    сравнения: VCL-программа на Delphi 10.2 Tokyo, создающая пустое окно без какого-либо полезного функционала, весит в 
                    release-версии целых 2 Мб (а в debug-версии… кхм, 11 Мб). На C++Builder 10.2 Tokyo release-версия такой же программы, 
                    не требующая внешних библиотек, получится размером ≈ 2.7 Мб. Аналогичная программа на fasm будет занимать всего пару 
                    килобайт.
                </li>
            </p>
            <p>
                <li>
                    Обычно одна строка кода на ЯВУ разворачивается в несколько (или даже десяток) инструкций процессора. А знаете ли вы о 
                    том, что некоторые инструкции процессора Intel требуют несколько строк для реализации на ЯВУ (на том же C/C++, если не 
                    использовать интринсики)? Если не знаете, просто поверьте на слово, а я, возможно, напишу об этом в одной из следующих 
                    статей. Приведу лишь один простой пример: аналоги инструкций rol, ror (существующих ещё в самых ранних процессорах 
                    i8086 с конца 70-х годов) появились только в стандарте C++20 в библиотеке bit (как функции std::rotl, std::rotr), а в 
                    большинстве других языков они вообще отсутствуют.
                </li>
            </p>
            <p>
                <li>
                    Есть такое направление компьютерного искусства: демосцена. Написать intro, уместив исполняемый файл в 256 байт 
                    [1, 2, 3, 4] (а то и 128, 64, 32 или даже ещё меньше) на чём-то отличном от ассемблера (ну или по крайней мере, без 
                    использования ассемблера для финальной корректировки кода) вы вряд ли сможете.
                </li>
            </p>
            <p>
                <li>
                    Ещё одна интересная область применения ассемблера – создание файлов данных с помощью макросов и директив генерации данных. К примеру, fasm 
                    позволяет создавать виртуальные данные и генерировать отдельные файлы (директива virtual), а также читать и изменять ранее 
                    сгенерированный код (директивы load, store). Есть даже примеры AES-шифрования файлов.
                </li>
            </p>
            <p>
                <li>
                    Без ассемблера не обойтись при исследовании (reverse engineering), а зачастую и при отладке программ.
                </li>
            </p>
        </ol>

        <h2 id="code">Примеры кода</h2>
        <figure class="codeFigire">
            <figcaption>Данная программа находит максимальное мнимое число и максимальное реальное.<br>
                Пример программы представлен на языке MASM32.</figcaption>
                <code class="codeFigire">
                <b>.486<br>
                .model flat, stdcall<br>
                option casemap :none</b><br>
                <b>include</b> windows.<span class="lib">inc</span><br>
                <b>include</b> kernel32.<span class="lib">inc</span><br>
                <b>include</b> masm32.<span class="lib">inc</span><br>
                <b>include</b> user32.<span class="lib">inc</span><br>
                <b>includelib</b> kernel32.lib<br>
                <b>includelib</b> masm32.lib<br>
                <b>includelib</b> user32.lib<br>
                <p></p>
                complex <b>struct</b><br>
	            <span class="mrgn">real</span> <span class="red">dq</span> ?<br>
                <span class="mrgn">imaginary</span> <span class="red">dq</span> ?<br>
                complex <b>ends</b><br>
                <p></p>
                <span class="section">.data</span><br>
                <div class="mrgn">
                    array complex &lt;1.0, -2.0&gt, &lt-4.5, 1.25&gt, &lt0.0, -3.1&gt, &lt3.5, -1.5&gt, &lt2.0, -3.0&gt<br>
                    zero <span class="typedata">dd</span> 0<br>
                    message <span class="typedata">db</span> <span class="string">'complex'</span> 10,0<br>
                    template_unr <span class="typedata">db</span> <span class="string">'Maximal by imaginary part: %s + (%s * i) '</span>, 10, 0 <br> 
                    template_r <span class="typedata">db</span> <span class="string">'Maximal by real part: %s + (%s * i)'</span>, 10, 0<br></div>
                <p></p>
                <span class="section">.data?</span><br>
                <div class="mrgn">
                    inputHandle <span class="typedata">dd</span> ?<br>
                    outputHandle <span class="typedata">dd</span> ?<br>
                    numberOfChars <span class="typedata">dd</span> ?<br>
                    inputBuffer <span class="typedata">dd</span> ?<br>
                    answer <span class="typedata">db</span> 100 <b>dup</b> (?)<br>
                    num_r <span class="typedata">dq</span> ?<br>
                    num_im <span class="typedata">dq</span> ?<br>
                    buf <span class="typedata">dd</span> ?<br>
                </div>
                <p></p>
                <span class="section">.code</span><br>
                <div class="mrgn">
                    <p></p>
                    complexCompareByRealPart:<br>
                    <div class="mrgn">
                        <span class="instruction">mov</span> <span class="register">EAX</span>,[<span class="register">ESP</span>+4]<br>
                        <span class="instruction">FLD</span> <span class="typedata">qword</span> <b>ptr</b> [ <span class="register">EAX</span>]<br>
                        <span class="instruction">mov</span> <span class="register">EAX</span>,[<span class="register">ESP</span>+8]<br>
                        <span class="instruction">FCOMP</span> <span class="typedata">qword</span> <b>ptr</b> [<span class="register">EAX</span>]<br>
                        <span class="instruction">FSTW</span> <span class="register">AX</span><br>
                        <span class="instruction">SAHF</span><br>
                        <span class="instruction">ja</span> great1<br>
                        <span class="instruction">jb</span> less1<br>
                        <span class="instruction">mov</span><span class="register"> EAX</span>,0<br>
                        <span class="instruction">jmp</span> return1<br>
                        <p></p>
                        great1:<br>
                        <div class="mrgn">
                            <span class="instruction">mov</span> <span class="register">EAX</span>,1<br>
                            <span class="instruction">jmp</span> return1<br>
                        </div>
                        <p></p>
                        less1:<br>
                        <div class="mrgn">
                            <span class="instruction">mov</span> <span class="register">EAX</span>,-1<br>
                        </div>
                        <p></p>
                        return1:<br>
                        <div class="mrgn">
                            <span class="instruction">ret</span> 8<br>
                        </div>
                    </div>
                        <p></p>
                        complexCompareByModulus:<br>
                        <div class="mrgn">
                            <span class="instruction">mov</span> <span class="register">EAX</span> [<span class="register">ESP</span>+8]<br>
                            <span class="instruction">FLD</span> <span class="typedata">qword</span> <b>ptr</b> [<span class="register">EAX</span>]<br>
                            <span class="instruction">FMUL</span> <span class="register">ST</span> (0) <span class="register">ST</span> (0)<br>
                            <span class="instruction">FADDP</span> <span class="register">ST</span> (1) <span class="register">ST</span> (0)<br>
                            <span class="instruction">mov</span> <span class="register">EAX</span> [<span class="register">ESP</span>+8]<br>
                            <span class="instruction">FLD</span> <span class="typedata">qword</span> <b>ptr</b> [<span class="register">EAX</span>]<br>
                            <span class="instruction">FMUL</span> <span class="register">ST</span> (0) <span class="register">ST</span> (0)<br>
                            <span class="instruction">FLD</span> <span class="typedata">qword</span> <b>ptr</b> [<span class="register">EAX</span>+8]<br>
                            <span class="instruction">FMUL</span> <span class="register">ST</span> (0) <span class="register">ST</span> (0)<br>
                            <span class="instruction">FADDP</span> <span class="register">ST</span> (1) <span class="register">ST</span> (0)<br>
                            <span class="instruction">FSUBP</span> <span class="register">ST</span> (1) <span class="register">ST</span> (0)<br>
                            <span class="instruction">FICOMP</span> zero<br>
                            <span class="instruction">FSTW</span> <span class="register">AX</span><br>
                            <span class="instruction">sahf</span><br>
                            <span class="instruction">ja</span> great2<br>
                            <span class="instruction">jb</span> less2<br>
                            <span class="instruction">mov</span><span class="register"> EAX</span>,0<br>
                            <span class="instruction">jmp</span> return2<br>
                            <p></p>
                            great2:<br>
                            <div class="mrgn">
                                <span class="instruction">mov</span> <span class="register">EAX</span>,1<br>
                                <span class="instruction">jmp</span> return2<br>
                            </div>
                            less2:<br>
                            <div class="mrgn">
                                <span class="instruction">mov</span> <span class="register">EAX</span>,-1<br>
                            </div>
                            return2:
                            <div class="mrgn">
                                <span class="instruction">ret</span> 8<br>
                            </div> 
                        </div>
                        <p></p>
                        max: 
                        <div class="mrgn">
                            <span class="instruction">mov</span> <span class="register">EBX</span> [<span class="register">ESP</span>+4]<br>
                            <span class="instruction">mov</span> <span class="register">ECX</span> [<span class="register">ESP</span>+8]<br>
                            <span class="instruction">mov</span> <span class="register">EDX</span> [<span class="register">ESP</span>+12]<br>
                            <span class="instruction">mov</span> <span class="register">ESI</span> <span class="register">EBX</span><br>                    
                        </div>
                        <p></p>
                        beginCycle:
                        <div class="mrgn">
                            <span class="instruction">cmp</span>  <span class="register">ECX</span>, 0<br>
                            <span class="instruction">je</span> endCycle
                            <span class="instruction">push</span> <span class="register">ESI</span><br>
                            <span class="instruction">push</span> <span class="register">EBX</span><br>
                            <span class="instruction">push</span> <span class="register">EDX</span><br>
                            <span class="instruction">cmp</span> <span class="register">EAX</span>, 0<br>
                            <span class="instruction">call</span> <span class="register">EDX</span><br>
                            <span class="instruction">cmp</span>  <span class="register">EAX</span>, 0<br>
                            <span class="instruction">jng</span> skip<br>
                            <span class="instruction">mov</span> <span class="register">ESI</span> <span class="register">EBX</span><br>
                            <p></p>
                            skip:<br>
                                                        <div class="mrgn">
                                <span class="instruction">add</span> <span class="register">EBX</span>, 16<br>
                                <span class="instruction">dec</span> <span class="register">ECX</span><br>
                                <span class="instruction">jmp</span> beginCycle<br>
                            </div>
                            <p></p>
                            endCycle:<br>
                            <div class="mrgn">
                                <span class="instruction">mov</span> <span class="register">EAX</span> <span class="register">ESI</span><br>
                                <span class="instruction">ret</span> 12<br>
                            </div>
                            <p></p>
                            start:<br>
                            <div class="mrgn">
                                <span class="instruction">push</span> <span class="handle"> STD_INPUT_HANDLE</span><br>
                                <span class="instruction">call</span> <span class="lib"> GetStdHandle</span><br>
                                <span class="instruction">mov</span> inputHandle, <span class="register">EAX</span><br>
                                <span class="instruction">push</span> <span class="handle"> STD_OUTPUT_HANDLE</span><br>
                                <span class="instruction">call</span> <span class="lib"> GetStdHandle</span><br>
                                <span class="instruction">mov</span> outputHandle, <span class="register">EAX</span><br>
                                <p></p>
                                <span class="instruction">push</span> <span class="handle"> NULL</span><br>
                                <span class="instruction">push</span> <b> offset</b> numberOfChars<br>
                                <span class="instruction">push</span> <span class="register">EAX</span><br>
                                <span class="instruction">push</span> outputHandle<br>
                                <span class="instruction">call</span> <span class="lib">WriteConsole</span><br>
                                <p></p>
                                <span class="instruction">push</span> complexCompareByModulus<br>
                                <p></p>
                                <span class="instruction">push</span> 5<br>
                                <span class="instruction">push</span> <b> offset</b> array<br>
                                <span class="instruction">call</span> max<br>
                                <p></p>
                                <span class="instruction">mov</span> buf, <span class="register">EAX</span><br>
                                <span class="instruction">push</span> <b>offset</b> num_r<br>
                                <span class="instruction">push</span>  <span class="typedata"> dword</span> <b>ptr</b> [<span class="register">EAX</span>+4]<br>
                                <span class="instruction">push</span>  <span class="typedata"> dword</span> <b>ptr</b> <span class="register">EAX</span><br>
                                <span class="instruction">call</span> <span class="lib"> FloatToStr</span><br>
                                <p></p>
                                <span class="instruction">mov</span>  <span class="register">EAX</span>, buf<br>
                                <span class="instruction">push</span> <b>offset</b> num_im<br>
                                <span class="instruction">push</span>  <span class="typedata">dword</span> <b>ptr</b> [<span class="register">EAX</span>+12]<br>
                                <span class="instruction">push</span>  <span class="typedata">dword</span> <b>ptr</b> [<span class="register">EAX</span>+8]<br>
                                <span class="instruction">call</span> <span class="lib">FloatToStr</span>
                                <p></p>
                                <span class="instruction">push</span> <b> offset</b> num_im<br>
                                <span class="instruction">push</span> <b> offset</b> num_r<br>
                                <span class="instruction">push</span> <b> offset</b> template_unr<br>
                                <span class="instruction">push</span> <b> offset</b> answer<br>
                                <span class="instruction">call</span> <span class="lib">wsprintf</span><br>
                                <span class="instruction">add</span> <span class="register">ESP</span>, 20<br>
                                <p></p>
                                <span class="instruction">push</span> <b> offset</b> answer<br>
                                <span class="instruction">call</span> <span class="lib"> lstrlen</span><br>
                                <span class="instruction">push</span> <span class="handle"> NULL</span><br>
                                <span class="instruction">push</span> <b>offset</b> numberOfChars<br>
                                <span class="instruction">push</span> <span class="register">EAX</span><br>
                                <span class="instruction">push</span> <b>offset</b> answer<br>
                                <span class="instruction">push</span> outputHandle<br>
                                <span class="instruction">call</span> <span class="lib"> WriteConsole</span><br>
                                <p></p>
                                <span class="instruction">push</span> <span class="handle"> NULL</span><br>
                                <span class="instruction">push</span> <b>offset</b> numberOfChars<br>
                                <span class="instruction">push</span> 1<br>
                                <span class="instruction">push</span> <b>offset</b> inputBuffer<br>
                                <span class="instruction">push</span> inputHandle<br>
                                <span class="instruction">call</span> <span class="lib"> ReadConsole</span><br>
                                <p></p>
                                <span class="instruction">push</span> 0<br>
                                <span class="instruction">call</span> <span class="lib"> ExitProcess</span><br>
                            </div>
                            
                        </div>
                        

                </div>
                <span class="section">end</span> start
            </code>
            
        </figure>
        <p></p>     
        <h2 id="using">Применение</h2>
        <p>Из-за того, что язык ассемблер трудноприменим для разработки объёмных программных комплексов, 
            стали появляться новые высокоуровневые языки, такие как Фортран, Лисп, Кобол, Паскаль, Си и другие.
             Именно они (и придуманные вслед за ними языки) сейчас активно используются в современных 
             информационных технологиях.
        </p>
        <p>
            Тем не менее и языки ассемблера остаются, что называется «при деле». Благодаря своим уникальным 
            достоинствам, они демонстрируют высокую эффективность и возможность задействования в полной мере 
            мощностей и уникального инструментария конкретной платформы.
        </p>
        <p>
            Язык ассемблер отлично подходит для написания программ, где важными критериями является:
            <ul class="mrgnBottom">
                <li class="mrgnBottom">скорость работы (игры, драйверы);</li>
                <li class="mrgnBottom">объём доступной для использования памяти (вирусные и защитные программы, встраиваемое ПО, программы для микроконтроллеров и микропроцессоров, загрузочные сектора).</li>
                <li class="mrgnBottom">Повышение скорости реагирования участков программ, написанных С++</li>
                <li class="mrgnBottom">Разработка операционных систем.</li>
                <li class="mrgnBottom">Написание программ для микроконтроллеров (МК) и микропроцессоров.</li>
                <li class="mrgnBottom">Разработка драйверов.</li>
                <li class="mrgnBottom">Написание защитных программ, антивирусов и т.п.</li>
                <li class="mrgnBottom">Разработка трансляторов для языков программирования.</li>
            </ul> 
        </p>
        <h2 id="after">Вывод</h2>
        <p>Вообще, на ассемблере, как на фундаменте, держится всё программирование с тех пор, как в мире появился первый процессор. Представьте себе, как физики, стремясь постичь 
            строение вселенной, ведут поиски тех самых неделимых низкоуровневых элементов, из которых она изначально создавалась. Но у ученых для этого есть лишь квантовая теория. 
            А вот первичной материей вселенной процессора как раз и является язык программирования ассемблер. Именно он раскрывает принцип работы машинных команд, без чего не обойтись 
            ни одному программисту, даже если конкретно на ассемблере он никогда ничего писать не будет. Это точно так же, как, не зная азов арифметики, нельзя стать математиком. 
            Не важно, на каком языке вы собираетесь писать коды, но вы должны иметь представление о том, как процессор будет реагировать на те или иные команды. В противном случае 
            программист станет наваливать в одну кучу известные ему операции, не особо понимая, каким будет конечный результат.А когда есть необходимость использования большого числа 
            компьютеров, объединенных одной целью, то во главу угла ставится невысокая себестоимость и большая скорость работы. И вот тут ассемблер вновь становится незаменимым 
            решением.
        </p>
        <p>
            Получается, что если вы разработчик приложений для мобильных устройств, то ассемблер – не для вас. Но если вы работаете на С, и используете микроконтроллер, то без 
            ассемблера здесь точно не обойтись, иначе вряд ли ваш путь в программировании будет успешным.
        </p>
        <hr>
        <a href="html/tags_styles.html" class="my-button ">Список тегов и стилей</a>

        <p>class="pref">тут находятся остальные 11 свойств</p>
    </body>
</html>
